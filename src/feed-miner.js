// Generated by CoffeeScript 1.9.1
var Agent, FeedParser, Lastfeed, checkFeedUpdates, cheerio, client, co, completeFeedPosts, coreq, fs, lastfeedTask, loadConfiguation, monitor, redis, request, setCachedFeed, sleep, subTask;

request = require('request');

Agent = require('socks5-http-client/lib/Agent');

FeedParser = require('feedparser');

co = require('co');

fs = require('mz/fs');

coreq = require('co-request');

cheerio = require('cheerio');

sleep = require('co-sleep');

redis = require('redis');

client = redis.createClient();

monitor = redis.createClient();

Lastfeed = require('./lib/lastfeed');

loadConfiguation = function*() {
  var configs, getAllConfigKeys, getConfigByKey, i, k, keys, len;
  getAllConfigKeys = function() {
    return new Promise(function(resolve, reject) {
      return client.keys('config:*', function(err, replies) {
        if (err != null) {
          return reject(err);
        } else {
          return resolve(replies);
        }
      });
    });
  };
  getConfigByKey = function(key) {
    return new Promise(function(resolve, reject) {
      return client.get(key, function(err, reply) {
        var config, e;
        if (err != null) {
          return reject(err);
        } else {
          try {
            config = JSON.parse(reply);
            return resolve(config);
          } catch (_error) {
            e = _error;
            return reject(e);
          }
        }
      });
    });
  };
  keys = (yield getAllConfigKeys());
  configs = [];
  for (i = 0, len = keys.length; i < len; i++) {
    k = keys[i];
    configs.push((yield getConfigByKey(k)));
  }
  return configs;
};

setCachedFeed = function(cacheKey, feedText) {
  console.log("caching: " + cacheKey);
  return client.set(cacheKey, feedText);
};

checkFeedUpdates = function*(lastfeed) {
  var cachedFeedText, feed, feedText, feedUpdated, promiseGetCachedRawFeed, promiseGetFeed;
  promiseGetCachedRawFeed = function(lastfeed) {
    return new Promise(function(resolve, reject) {
      var feedKey;
      feedKey = lastfeed.feedRawKey;
      return client.get(feedKey, function(err, reply) {
        if (err != null) {
          console.log(err);
          return reject(err);
        } else {
          return resolve(reply);
        }
      });
    });
  };
  promiseGetFeed = function(lastfeed) {
    return new Promise(function(resolve, reject) {
      var feed, feedparser, req, url;
      url = lastfeed.config.url;
      console.log("request feed: " + url);
      req = request(url);
      feedparser = new FeedParser();
      feed = {};
      feed.meta = null;
      feed.articles = [];
      req.on('error', function(error) {
        return reject(error);
      });
      req.on('response', function(resp) {
        if (resp.statusCode !== 200) {
          this.emit('error', new Error('Bad status code'));
        }
        return this.pipe(feedparser);
      });
      feedparser.on('error', function(error) {
        return reject(error);
      });
      feedparser.on('readable', function() {
        var post, results;
        results = [];
        while (post = this.read()) {
          results.push(feed.articles.push(post));
        }
        return results;
      });
      feedparser.on('meta', function(meta) {
        return feed.meta = meta;
      });
      return feedparser.on('end', function() {
        return resolve(feed);
      });
    });
  };
  feed = (yield promiseGetFeed(lastfeed));
  feedText = JSON.stringify(feed);
  cachedFeedText = (yield promiseGetCachedRawFeed(lastfeed));
  fs.writeFileSync('./cached.json', cachedFeedText);
  fs.writeFileSync('./response.json', feedText);
  if (cachedFeedText === feedText) {
    feedUpdated = false;
  } else {
    feedUpdated = true;
  }
  return {
    feed: feed,
    feedUpdated: feedUpdated
  };
};

completeFeedPosts = function*(lastfeed) {
  var article, feedCacheString, i, len, postText, postUrl, ref, resp;
  ref = lastfeed.feed.articles;
  for (i = 0, len = ref.length; i < len; i++) {
    article = ref[i];
    postUrl = article.link;
    console.log(postUrl);
    resp = (yield coreq(postUrl));
    postText = lastfeed.parser.parse(resp.body);
    article.description = postText;
  }
  feedCacheString = JSON.stringify(lastfeed.feed);
  setCachedFeed(lastfeed.feedCacheKey, feedCacheString);
  return fs.writeFileSync("./posttext.html", feedCacheString);
};

lastfeedTask = function*(lastfeed) {
  var rawFeedText, value;
  value = (yield checkFeedUpdates(lastfeed));
  lastfeed.feed = value.feed;
  lastfeed.feedUpdated = value.feedUpdated;
  rawFeedText = JSON.stringify(lastfeed.feed);
  console.log("feed updated: " + lastfeed.feedUpdated);
  if (lastfeed.feedUpdated) {
    value = (yield completeFeedPosts(lastfeed));
    setCachedFeed(lastfeed.feedRawKey, rawFeedText);
    console.log("completeFeedPosts");
  }
  return lastfeed;
};

subTask = function(lastfeed) {
  return co(function*() {
    var results;
    results = [];
    while (true) {
      console.log("");
      console.log("task: " + lastfeed.feedId);
      console.log("parser: " + lastfeed.parser.id);
      (yield lastfeedTask(lastfeed));
      console.log("sleep " + lastfeed.config.interval + ": " + lastfeed.feedId);
      results.push((yield sleep(lastfeed.config.interval)));
    }
    return results;
  }).then(function(c) {
    return console.log("sub then");
  })["catch"](function(err) {
    return console.log(err);
  });
};

co(function*() {
  var c, configs, i, lastfeed, len, results;
  configs = (yield loadConfiguation());
  results = [];
  for (i = 0, len = configs.length; i < len; i++) {
    c = configs[i];
    lastfeed = new Lastfeed(c);
    results.push(subTask(lastfeed));
  }
  return results;
}).then(function(c) {
  return console.log("main then");
})["catch"](function(err) {
  return console.log(err);
});
